Final Project Development Summary: Command-Line Task/Habit Manager
Introduction
This summary explains the development process for the Python command-line Task/Habit Manager. The project consisted of five distinct phases, progressing from a fully persistent Command-Line Interface (CLI) to an experimental AI integration, and culminating in a simplified menu-driven prototype. I learned a lot throughout this project, like how to use AI assistance in a correctly way to complete the project successfully. I used both GitHub Copilot while coding and Gemini to have everything structured correctly. Gemini helped define the module separation (utils.py, tasks.py) while Copilot handled function signature generation. The analysis below explains what is going on in the phases to have a better understanding.
The first phase consisted of tasks 1 and 2. In these tasks, I implemented full CLI applications using JSON persistence and CRD functions such as add, list, done, and delete. This helped structure all my prototypes for they can be managed in a good way. Task 3 is where I started the integration of pytest and modular setup for core functions. In task 4 is where I integrated API I used copilot and Open Ai to help structure correctly my text. In task 4 is where I experimented with functions and loops to make my task manager accessible and functional. In the last task, task 5 I simplified prototype for the interactions could be effective.
AI assistance was critical in my development of the project. I utilized Gemini integration for architecture and complex feature implementation: I used Gemini to generate the initial structure for file handling, specifically asking for a Python function that uses json.load() and handles edge cases like FileNotFoundError and JSONDecodeError. The resulting robust load_tasks function, which initializes an empty list upon error, was adopted directly into the initial prototype. I was also using the lectures to be able to do this correctly. Both Gemini and the lecture helped me correctly implement the code structure and revise my code. In task 3 to implement professional testing, I used Gemini to help define the pytest.fixture needed for test_task.py. The model provided the template for using tmp_path to mock the tasks.json file, ensuring every test ran with a clean, isolated dataset. 
Github Copilot served an important role as well because it accelerated day-to-day coding by generating repetitive structures and common function patterns directly in the VS Code editor. In task two when expanding the CLI to include done <id> and delete <id>, Copilot provided the necessary conditional logic to check len(sys.argv) < 3 for argument validation, ensuring the application gracefully handled missing IDs. In the search_tasks and delete_task functions, Copilot easily generated the list comprehension logic (e.g., tasks = [task for task in tasks if task['id'] != task_id]), saving time on complex filtering operations.
Now going on of what worked for me during the process of my project. In task 4 a very important thing that I did was the seamless integration of the OpenAI API. I used the AI to generate the entire summarize_task function, including the try-except block for API errors, the system_prompt definition for concise summarization, and the correct client.chat.completions.create structure. This allowed a complex, external feature to be integrated in a single development phase. While that was something that worked successfully for me there was another thing that did not work for me such as: The AI could not assist with the fundamental step of setting the OPENAI_API_KEY environment variable. The developer had to manually research and implement the sys.exit(1) block to gracefully handle this missing key at runtime, highlighting the limitations of AI-coding assistance outside of the code block itself.
In conclusion this project was a hands off human and AI working together to create something successful. The most crucial development work involved overriding or correcting AI suggestions when they conflicted with the core project requirements, such as enforcing index-based deletion in remove_task. The final software is a stable, functional command-line tool achieved through this effective human-AI partnership.



